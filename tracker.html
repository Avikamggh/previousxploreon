<!DOCTYPE html>
<html lang="en">
<head>

<!-- Custom Cursor Styles -->
<link rel="stylesheet" href="customcursor.css">

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Xploreon | Enhanced Satellite Tracker with Pass Predictions</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      background: #0a0a0a;
      color: #ffffff;
      overflow-x: hidden;
    }
    
    #map {
      height: 100vh;
      width: 100%;
    }
    
    .leaflet-control-attribution {
      display: none;
    }
    
    .back-xploreon-btn {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(45deg, #00ffe0, #00d4aa);
      color: #000;
      padding: 12px 20px;
      font-weight: 700;
      border-radius: 25px;
      font-family: 'Orbitron', sans-serif;
      box-shadow: 0 0 20px rgba(0, 255, 224, 0.5);
      text-decoration: none;
      z-index: 1000;
      white-space: nowrap;
      transition: all 0.3s ease;
      border: 2px solid #00ffe0;
      font-size: 14px;
    }

    .back-xploreon-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 224, 0.8);
      background: linear-gradient(45deg, #00d4aa, #00ffe0);
    }

    .control-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(10, 10, 10, 0.95);
      padding: 20px;
      border-radius: 15px;
      border: 2px solid #00ffe0;
      color: white;
      font-family: 'Orbitron', sans-serif;
      min-width: 320px;
      max-width: 350px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(0, 255, 224, 0.3);
      max-height: 90vh;
      overflow-y: auto;
      transition: all 0.3s ease;
    }

    .panel-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(10, 10, 10, 0.9);
      color: #00ffe0;
      border: 2px solid #00ffe0;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .panel-toggle:hover {
      background: #00ffe0;
      color: black;
      transform: scale(1.1);
    }

    .panel-title {
      color: #00ffe0;
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 15px;
      text-align: center;
      text-shadow: 0 0 10px #00ffe0;
    }

    .satellite-selector {
      margin-bottom: 15px;
    }

    .satellite-selector select {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ffe0;
      border: 1px solid #00ffe0;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
    }

    .control-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .control-btn {
      flex: 1;
      min-width: 90px;
      background: linear-gradient(45deg, #00ffe0, #00d4aa);
      color: black;
      border: none;
      padding: 8px 10px;
      border-radius: 6px;
      font-weight: 600;
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .control-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 255, 224, 0.6);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .satellite-info {
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #00ffe0;
      font-size: 11px;
      line-height: 1.4;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(0, 255, 224, 0.2);
    }

    .info-label {
      color: #00ffe0;
      font-weight: 600;
    }

    .info-value {
      color: #ffffff;
      font-weight: 400;
    }

    .satellite-icon {
      font-size: 28px;
      text-align: center;
      line-height: 32px;
      filter: drop-shadow(0 0 8px #00ffe0);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .satellite-label {
      color: #ffffff;
      font-size: 18px;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 10px #00ffe0;
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 8px;
      border-radius: 50%;
      border: 1px solid rgba(0, 255, 224, 0.5);
      backdrop-filter: blur(5px);
      white-space: nowrap;
    }

    .orbit-path {
      stroke: #00ffe0;
      stroke-width: 2;
      fill: none;
      opacity: 0.6;
      stroke-dasharray: 5,5;
      animation: dash 20s linear infinite;
    }

    @keyframes dash {
      to { stroke-dashoffset: -200; }
    }

    .map-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      display: flex;
      gap: 10px;
    }

    .map-btn {
      background: rgba(10, 10, 10, 0.9);
      color: #00ffe0;
      border: 2px solid #00ffe0;
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 12px;
    }

    .map-btn:hover, .map-btn.active {
      background: #00ffe0;
      color: black;
      box-shadow: 0 0 15px rgba(0, 255, 224, 0.6);
    }

    .status-indicator {
      text-align: center;
      color: #00ffe0;
      font-size: 10px;
      margin: 10px 0;
      opacity: 0.8;
      padding: 8px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 224, 0.3);
    }

    .tle-status {
      background: rgba(0, 0, 0, 0.7);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #00ffe0;
      margin-bottom: 15px;
      font-size: 11px;
      text-align: center;
    }

    .tle-status.loading {
      border-color: #ffaa00;
      color: #ffaa00;
      animation: loading-pulse 1.5s infinite;
    }

    .tle-status.success {
      border-color: #00ff00;
      color: #00ff00;
    }

    .tle-status.error {
      border-color: #ff0000;
      color: #ff0000;
    }

    @keyframes loading-pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .cors-info {
      background: rgba(0, 100, 200, 0.1);
      border: 1px solid #0080ff;
      color: #80c0ff;
      padding: 10px;
      border-radius: 6px;
      font-size: 9px;
      margin-bottom: 15px;
      text-align: center;
    }

    .pass-info {
      background: rgba(255, 165, 0, 0.1);
      border: 1px solid #ffa500;
      color: #ffcc80;
      padding: 8px;
      border-radius: 6px;
      font-size: 9px;
      margin-top: 10px;
      text-align: center;
    }

    .pass-info.visible {
      background: rgba(0, 255, 0, 0.1);
      border-color: #00ff00;
      color: #80ff80;
    }

    .pass-info.soon {
      background: rgba(255, 255, 0, 0.1);
      border-color: #ffff00;
      color: #ffff80;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.6; }
    }

    .user-location-marker {
      background: #ff4444;
      border: 2px solid #ffffff;
      border-radius: 50%;
      width: 12px;
      height: 12px;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      .control-panel {
        top: 70px;
        right: 10px;
        left: 10px;
        min-width: auto;
        max-width: none;
        padding: 15px;
        max-height: 60vh;
        transform: translateY(-100%);
        opacity: 0;
        pointer-events: none;
      }

      .control-panel.mobile-open {
        transform: translateY(0);
        opacity: 1;
        pointer-events: all;
      }

      .panel-toggle {
        display: flex !important;
        top: 15px;
        right: 15px;
      }
      
      .map-toggle {
        top: 15px;
        left: 15px;
        flex-direction: row;
        gap: 5px;
      }
      
      .map-btn {
        padding: 8px 12px;
        font-size: 11px;
      }

      .control-buttons {
        gap: 5px;
      }

      .control-btn {
        min-width: 70px;
        padding: 6px 8px;
        font-size: 9px;
      }

      .back-xploreon-btn {
        bottom: 15px;
        padding: 10px 16px;
        font-size: 12px;
      }

      .panel-title {
        font-size: 14px;
        margin-bottom: 10px;
      }

      .satellite-info {
        font-size: 10px;
        padding: 10px;
      }

      .cors-info {
        padding: 8px;
        font-size: 8px;
        margin-bottom: 10px;
      }

      .tle-status {
        padding: 8px;
        font-size: 10px;
        margin-bottom: 10px;
      }

      .status-indicator {
        padding: 6px;
        font-size: 9px;
        margin: 8px 0;
      }

      .info-row {
        margin-bottom: 6px;
        padding: 2px 0;
      }

      .pass-info {
        padding: 6px;
        font-size: 8px;
        margin-top: 8px;
      }
    }

    @media (max-width: 480px) {
      .control-panel {
        padding: 12px;
        border-radius: 10px;
        max-height: 50vh;
      }

      .control-btn {
        min-width: 60px;
        font-size: 8px;
        padding: 4px 6px;
      }

      .map-btn {
        padding: 6px 8px;
        font-size: 10px;
      }

      .back-xploreon-btn {
        padding: 8px 12px;
        font-size: 11px;
      }

      .satellite-label {
        font-size: 14px;
      }

      .panel-toggle {
        width: 45px;
        height: 45px;
        font-size: 18px;
      }

      .satellite-info {
        font-size: 9px;
      }

      .panel-title {
        font-size: 13px;
      }
    }

    /* Custom scrollbar */
    .control-panel::-webkit-scrollbar {
      width: 6px;
    }

    .control-panel::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 3px;
    }

    .control-panel::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 224, 0.5);
      border-radius: 3px;
    }

    .control-panel::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 224, 0.8);
    }
  </style>
</head>
<body>

<a href="index.html" class="back-xploreon-btn">üöÄ Back to Xploreon</a>

<div class="map-toggle">
  <button class="map-btn active" onclick="switchMapType('satellite')">üõ∞Ô∏è Satellite</button>
  <button class="map-btn" onclick="switchMapType('street')">üó∫Ô∏è Street</button>
</div>

<div id="map"></div>

<div class="panel-toggle" id="panelToggle" onclick="toggleMobilePanel()">
  üì°
</div>

<div class="control-panel" id="controlPanel">
  <div class="panel-title">üõ∞Ô∏è LIVE SATELLITE TRACKER</div>
  
  <div class="cors-info">
    üåê CORS-Enabled | Live TLE Data from Celestrak
  </div>
  
  <div class="tle-status" id="tleStatus">
    üîÑ Initializing satellite data...
  </div>
  
  <div class="satellite-selector">
    <select id="satDropdown">
      <option value="">-- Loading Satellites --</option>
    </select>
  </div>

  <div class="control-buttons">
    <button class="control-btn" onclick="showAllSatellites()">Show All</button>
    <button class="control-btn" onclick="clearAllSatellites()">Clear All</button>
    <button class="control-btn" onclick="toggleOrbits()">Orbits</button>
    <button class="control-btn" onclick="updateTLEData()" id="updateBtn">Refresh TLE</button>
  </div>

  <div class="status-indicator">
    üîÑ Position Updates: <span id="updateStatus">Active</span>
    <br>
    üì° TLE Age: <span id="tleAge">--</span>
    <br>
    üõ∞Ô∏è Satellites: <span id="satCount">0</span>
    <br>
    üìç Location: <span id="locationStatus">Detecting location...</span>
  </div>

  <div class="satellite-info" id="satelliteInfo">
    <div style="text-align: center; color: #00ffe0; margin: 20px 0;">
      üöÄ Loading satellite constellation...
    </div>
  </div>
</div>

<script>
  // Configuration
  const CONFIG = {
    TLE_UPDATE_INTERVAL: 6 * 60 * 60 * 1000, // 6 hours
    POSITION_UPDATE_INTERVAL: 1000, // 1 second
    AUTO_UPDATE_ENABLED: true,
    MAX_SATELLITES: 50, // Limit for performance
    ORBIT_POINTS: 90, // Number of points for orbit visualization
    USER_LOCATION: {
      lat: 0, // Global center as fallback
      lng: 0,
      elevation: 0.1, // km above sea level
      name: "Location not set"
    },
    MIN_ELEVATION: 10, // Minimum elevation angle for visibility (degrees)
    PASS_PREDICTION_HOURS: 24 // Hours ahead to predict passes
  };

  // CORS Proxy Services (Multiple fallbacks)
  const CORS_PROXIES = [
    {
      name: "AllOrigins",
      url: (targetUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`,
      active: true
    },
    {
      name: "CORS Proxy",
      url: (targetUrl) => `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
      active: true
    },
    {
      name: "ThingProxy",
      url: (targetUrl) => `https://thingproxy.freeboard.io/fetch/${targetUrl}`,
      active: true
    }
  ];

  // Celestrak TLE Sources
  const TLE_SOURCES = {
    stations: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=stations&FORMAT=tle',
    weather: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=weather&FORMAT=tle',
    noaa: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=noaa&FORMAT=tle',
    visual: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=visual&FORMAT=tle',
    active: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle'
  };

  // Featured satellites with custom icons
  const FEATURED_SATELLITES = {
    25544: { name: "ISS (International Space Station)", icon: "üè†" },
    48274: { name: "TIANGONG (Chinese Space Station)", icon: "üèõÔ∏è" },
    20580: { name: "Hubble Space Telescope", icon: "üî≠" },
    33591: { name: "NOAA 19 (Weather)", icon: "üå¶Ô∏è" },
    43013: { name: "NOAA 20 (JPSS-1)", icon: "‚õàÔ∏è" },
    41866: { name: "GOES-16 (Weather)", icon: "üå™Ô∏è" },
    25994: { name: "TERRA (Earth Observation)", icon: "üåç" },
    27424: { name: "AQUA (Earth Observation)", icon: "üåä" },
    39084: { name: "LANDSAT 8", icon: "üì∏" },
    49260: { name: "LANDSAT 9", icon: "üì∑" },
    43692: { name: "SENTINEL-3B", icon: "üõ∞Ô∏è" },
    40069: { name: "GOES-15 (Weather)", icon: "‚õÖ" },
    29155: { name: "METOP-A (Weather)", icon: "üå°Ô∏è" },
    38771: { name: "METOP-B (Weather)", icon: "üå®Ô∏è" },
    43689: { name: "METOP-C (Weather)", icon: "‚ùÑÔ∏è" }
  };

  // Global variables
  let map, satelliteLayer, streetLayer;
  let tleData = [];
  let markers = [];
  let orbitPaths = [];
  let selectedSatellite = null;
  let showOrbits = false;
  let updateInterval, tleUpdateInterval;
  let lastTLEUpdate = null;
  let workingProxy = null;
  let isMobile = window.innerWidth <= 768;
  let mobileMenuOpen = false;
  let userLocationMarker = null;
  let locationStatus = "Detecting location...";
  let hasRealLocation = false;

  // Geolocation functions
  function requestUserLocation() {
    updateLocationStatus("üåç Requesting your location...");
    
    if (!navigator.geolocation) {
      console.warn('Geolocation not supported by this browser');
      updateLocationStatus("‚ùå Geolocation not supported");
      return;
    }

    const options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 300000 // 5 minutes
    };

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        const accuracy = position.coords.accuracy;
        
        // Update config with real location
        CONFIG.USER_LOCATION.lat = lat;
        CONFIG.USER_LOCATION.lng = lng;
        CONFIG.USER_LOCATION.elevation = 0.1; // Assume close to sea level
        
        hasRealLocation = true;
        
        // Get location name via reverse geocoding (optional)
        getLocationName(lat, lng);
        
        // Update marker position and add to map
        if (userLocationMarker) {
          userLocationMarker.setLatLng([lat, lng]);
          userLocationMarker.addTo(map);
          userLocationMarker.bindPopup(`üìç Your Location<br>Lat: ${lat.toFixed(4)}¬∞<br>Lng: ${lng.toFixed(4)}¬∞<br>Accuracy: ¬±${Math.round(accuracy)}m`, {
            offset: [0, -12]
          });
        }
        
        // Center map on user location
        map.setView([lat, lng], 6);
        
        updateLocationStatus(`üìç Location acquired (¬±${Math.round(accuracy)}m)`);
        console.log(`‚úÖ Location: ${lat.toFixed(4)}, ${lng.toFixed(4)} (¬±${Math.round(accuracy)}m)`);
      },
      (error) => {
        console.error('Geolocation error:', error);
        let errorMsg = "‚ùå Location denied";
        
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMsg = "‚ùå Location permission denied";
            updateLocationStatus("üìç Location access denied");
            break;
          case error.POSITION_UNAVAILABLE:
            errorMsg = "‚ùå Location unavailable";
            updateLocationStatus("üìç Location unavailable");
            break;
          case error.TIMEOUT:
            errorMsg = "‚ùå Location timeout";
            updateLocationStatus("üìç Location request timed out");
            break;
        }
        
        console.warn(errorMsg);
        // Keep using fallback location
        CONFIG.USER_LOCATION.name = "Location not available";
      },
      options
    );
  }

  // Optional: Get location name from coordinates using multiple services
  async function getLocationName(lat, lng) {
    try {
      // Try multiple geocoding services for better accuracy
      const services = [
        {
          name: "Nominatim",
          url: `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=12&addressdetails=1`,
          parser: (data) => {
            if (data.address) {
              // Prefer smaller localities over major cities
              const city = data.address.village || data.address.town || data.address.city || data.address.county;
              const country = data.address.country_code?.toUpperCase();
              return city && country ? `${city}, ${country}` : null;
            }
            return null;
          }
        },
        {
          name: "BigDataCloud",
          url: `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=en`,
          parser: (data) => {
            if (data.locality && data.countryCode) {
              return `${data.locality}, ${data.countryCode}`;
            } else if (data.city && data.countryCode) {
              return `${data.city}, ${data.countryCode}`;
            }
            return null;
          }
        }
      ];

      for (const service of services) {
        try {
          console.log(`Trying ${service.name} for location...`);
          const response = await fetch(service.url, {
            headers: {
              'User-Agent': 'SatelliteTracker/1.0'
            }
          });
          const data = await response.json();
          const locationName = service.parser(data);
          
          if (locationName) {
            // Check if we're getting a more specific location than just "Meerut"
            if (locationName.includes('Meerut') && service.name === "Nominatim") {
              console.log('Checking for more specific locality...');
              continue; // Try next service for more specific location
            }
            
            CONFIG.USER_LOCATION.name = locationName;
            updateLocationStatus(`üìç ${locationName}`);
            console.log(`‚úÖ Location from ${service.name}: ${locationName}`);
            return;
          }
        } catch (error) {
          console.warn(`${service.name} failed:`, error.message);
          continue;
        }
      }
      
      // If all services fail or return generic locations, use a simple name
      CONFIG.USER_LOCATION.name = "Your Location";
      updateLocationStatus("üìç Location detected");
      
    } catch (error) {
      console.warn('All reverse geocoding failed:', error);
      CONFIG.USER_LOCATION.name = hasRealLocation ? "Your Location" : "Location not available";
      updateLocationStatus(CONFIG.USER_LOCATION.name);
    }
  }

  // Update location status in UI
  function updateLocationStatus(status) {
    locationStatus = status;
    // Update status will be called by updateStatusIndicators
  }

  // Mobile panel toggle function
  function toggleMobilePanel() {
    const panel = document.getElementById('controlPanel');
    const toggle = document.getElementById('panelToggle');
    
    mobileMenuOpen = !mobileMenuOpen;
    
    if (mobileMenuOpen) {
      panel.classList.add('mobile-open');
      toggle.textContent = '‚úï';
      toggle.style.background = '#ff4444';
      toggle.style.borderColor = '#ff4444';
    } else {
      panel.classList.remove('mobile-open');
      toggle.textContent = 'üì°';
      toggle.style.background = 'rgba(10, 10, 10, 0.9)';
      toggle.style.borderColor = '#00ffe0';
    }
  }

  // Handle window resize
  function handleResize() {
    const waseMobile = isMobile;
    isMobile = window.innerWidth <= 768;
    
    if (waseMobile && !isMobile) {
      document.getElementById('controlPanel').classList.remove('mobile-open');
      mobileMenuOpen = false;
      const toggle = document.getElementById('panelToggle');
      toggle.textContent = 'üì°';
      toggle.style.background = 'rgba(10, 10, 10, 0.9)';
      toggle.style.borderColor = '#00ffe0';
    }
  }

  // Initialize map
  function initializeMap() {
    map = L.map('map').setView([20, 0], 2); // Global view initially
    
    // Map layers
    satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: '¬© Esri'
    });
    
    streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap'
    });
    
    // Start with satellite view
    satelliteLayer.addTo(map);
    
    // Add user location marker (hidden initially, will show when location is obtained)
    userLocationMarker = L.marker([CONFIG.USER_LOCATION.lat, CONFIG.USER_LOCATION.lng], {
      icon: L.divIcon({
        className: 'user-location-marker',
        html: 'üìç',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      }),
      title: 'Your Location'
    }); // Not added to map initially
    
    // Request real location
    setTimeout(requestUserLocation, 1000); // Small delay to let map load first
  }

  // Calculate look angles (azimuth, elevation) from observer to satellite
  function calculateLookAngles(observerLat, observerLng, observerAlt, satellitePos) {
    const observerLatRad = observerLat * Math.PI / 180;
    const observerLngRad = observerLng * Math.PI / 180;
    const earthRadius = 6371; // km
    
    // Observer position in ECEF
    const observerECEF = {
      x: (earthRadius + observerAlt) * Math.cos(observerLatRad) * Math.cos(observerLngRad),
      y: (earthRadius + observerAlt) * Math.cos(observerLatRad) * Math.sin(observerLngRad),
      z: (earthRadius + observerAlt) * Math.sin(observerLatRad)
    };
    
    // Vector from observer to satellite
    const dx = satellitePos.x - observerECEF.x;
    const dy = satellitePos.y - observerECEF.y;
    const dz = satellitePos.z - observerECEF.z;
    
    // Range
    const range = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    // Local coordinate system (ENU - East, North, Up)
    const east = -Math.sin(observerLngRad) * dx + Math.cos(observerLngRad) * dy;
    const north = -Math.sin(observerLatRad) * Math.cos(observerLngRad) * dx - 
                   Math.sin(observerLatRad) * Math.sin(observerLngRad) * dy + 
                   Math.cos(observerLatRad) * dz;
    const up = Math.cos(observerLatRad) * Math.cos(observerLngRad) * dx + 
               Math.cos(observerLatRad) * Math.sin(observerLngRad) * dy + 
               Math.sin(observerLatRad) * dz;
    
    // Calculate azimuth (0 = North, 90 = East)
    let azimuth = Math.atan2(east, north) * 180 / Math.PI;
    if (azimuth < 0) azimuth += 360;
    
    // Calculate elevation
    const elevation = Math.atan2(up, Math.sqrt(east*east + north*north)) * 180 / Math.PI;
    
    return {
      azimuth: azimuth,
      elevation: elevation,
      range: range
    };
  }

  // Predict next satellite pass
  function predictNextPass(satrec, hoursAhead = 24) {
    const startTime = new Date();
    const endTime = new Date(startTime.getTime() + hoursAhead * 60 * 60 * 1000);
    const stepMinutes = 1;
    let passes = [];
    let currentPass = null;
    let wasVisible = false;
    
    try {
      for (let time = new Date(startTime); time <= endTime; time.setMinutes(time.getMinutes() + stepMinutes)) {
        const position = satellite.propagate(satrec, time);
        
        if (!position.position || position.error) continue;
        
        const lookAngles = calculateLookAngles(
          CONFIG.USER_LOCATION.lat,
          CONFIG.USER_LOCATION.lng,
          CONFIG.USER_LOCATION.elevation,
          position.position
        );
        
        const isVisible = lookAngles.elevation >= CONFIG.MIN_ELEVATION;
        
        // Pass start
        if (isVisible && !wasVisible) {
          currentPass = {
            startTime: new Date(time),
            maxElevation: lookAngles.elevation,
            maxElevationTime: new Date(time)
          };
        }
        
        // Update max elevation during pass
        if (isVisible && currentPass && lookAngles.elevation > currentPass.maxElevation) {
          currentPass.maxElevation = lookAngles.elevation;
          currentPass.maxElevationTime = new Date(time);
        }
        
        // Pass end
        if (!isVisible && wasVisible && currentPass) {
          currentPass.endTime = new Date(time.getTime() - stepMinutes * 60 * 1000);
          currentPass.duration = (currentPass.endTime - currentPass.startTime) / 1000 / 60; // minutes
          
          if (currentPass.duration > 1) { // Only include passes longer than 1 minute
            passes.push(currentPass);
          }
          currentPass = null;
        }
        
        wasVisible = isVisible;
        
        // Limit to first 3 passes for performance
        if (passes.length >= 3) break;
      }
    } catch (error) {
      console.error('Pass prediction error:', error);
    }
    
    return passes;
  }

  // Format time for display
  function formatTime(date) {
    return date.toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit',
      hour12: false 
    });
  }

  // Format date for display
  function formatDate(date) {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    if (date.toDateString() === today.toDateString()) {
      return 'Today';
    } else if (date.toDateString() === tomorrow.toDateString()) {
      return 'Tomorrow';
    } else {
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
  }

  // Update TLE status display
  function updateTLEStatus(type, message) {
    const statusElement = document.getElementById('tleStatus');
    statusElement.className = `tle-status ${type}`;
    statusElement.textContent = message;
  }

  // Update status indicators
  function updateStatusIndicators() {
    document.getElementById('satCount').textContent = tleData.length;
    
    if (lastTLEUpdate) {
      const ageHours = Math.floor((Date.now() - lastTLEUpdate.getTime()) / (1000 * 60 * 60));
      document.getElementById('tleAge').textContent = `${ageHours}h`;
    }
    
    // Update location status
    document.getElementById('locationStatus').textContent = locationStatus;
  }

  // Fetch TLE data with CORS proxy fallback
  async function fetchWithCORSProxy(url) {
    const activeProxies = CORS_PROXIES.filter(proxy => proxy.active);
    
    for (const proxy of activeProxies) {
      try {
        updateTLEStatus('loading', `üì° Trying ${proxy.name}...`);
        console.log(`Attempting fetch with ${proxy.name}`);
        
        const proxyUrl = proxy.url(url);
        const response = await fetch(proxyUrl, {
          method: 'GET',
          headers: {
            'Accept': 'text/plain',
          },
          signal: AbortSignal.timeout(15000) // 15 second timeout
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.text();
        
        if (data && data.includes('1 ') && data.includes('2 ') && data.length > 100) {
          console.log(`‚úÖ Success with ${proxy.name}`);
          workingProxy = proxy;
          return data;
        } else {
          throw new Error('Invalid TLE format received');
        }
      } catch (error) {
        console.warn(`${proxy.name} failed:`, error.message);
        continue;
      }
    }
    
    throw new Error('All CORS proxies failed');
  }

  // Parse TLE data from text
  function parseTLEData(tleText) {
    const lines = tleText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const satellites = [];
    
    for (let i = 0; i < lines.length && satellites.length < CONFIG.MAX_SATELLITES; i += 3) {
      if (i + 2 < lines.length) {
        const name = lines[i];
        const tle1 = lines[i + 1];
        const tle2 = lines[i + 2];
        
        const noradMatch = tle1.match(/^1 (\d+)/);
        if (!noradMatch) continue;
        
        const noradId = parseInt(noradMatch[1]);
        const featured = FEATURED_SATELLITES[noradId];
        
        if (featured || name.includes('ISS') || name.includes('NOAA') || 
            name.includes('GOES') || name.includes('TERRA') || name.includes('AQUA') ||
            name.includes('LANDSAT') || name.includes('METOP') || name.includes('SENTINEL') ||
            name.includes('TIANGONG') || name.includes('HUBBLE')) {
          
          satellites.push({
            name: featured ? featured.name : name.replace(/\s+/g, ' ').trim(),
            icon: featured ? featured.icon : 'üõ∞Ô∏è',
            noradId: noradId,
            tle1: tle1,
            tle2: tle2
          });
        }
      }
    }
    
    return satellites;
  }

  // Fetch TLE data from multiple sources
  async function updateTLEData() {
    updateTLEStatus('loading', 'üîÑ Fetching fresh TLE data...');
    document.getElementById('updateBtn').disabled = true;
    
    try {
      const allSatellites = [];
      const primarySources = ['stations', 'weather', 'noaa', 'visual'];
      
      for (const source of primarySources) {
        try {
          const tleText = await fetchWithCORSProxy(TLE_SOURCES[source]);
          const satellites = parseTLEData(tleText);
          allSatellites.push(...satellites);
          console.log(`Loaded ${satellites.length} satellites from ${source}`);
        } catch (error) {
          console.warn(`Failed to load ${source}:`, error.message);
        }
      }
      
      if (allSatellites.length > 0) {
        const uniqueSatellites = allSatellites.filter((sat, index, arr) => 
          arr.findIndex(s => s.noradId === sat.noradId) === index
        );
        
        uniqueSatellites.sort((a, b) => {
          const aFeatured = FEATURED_SATELLITES[a.noradId] ? 1 : 0;
          const bFeatured = FEATURED_SATELLITES[b.noradId] ? 1 : 0;
          return bFeatured - aFeatured || a.name.localeCompare(b.name);
        });
        
        tleData = uniqueSatellites.slice(0, CONFIG.MAX_SATELLITES);
        lastTLEUpdate = new Date();
        
        updateTLEStatus('success', `‚úÖ Loaded ${tleData.length} satellites (${workingProxy?.name})`);
        populateDropdown();
        clearAllMarkers();
        updateStatusIndicators();
        
        localStorage.setItem('satelliteTLEData', JSON.stringify({
          data: tleData,
          timestamp: lastTLEUpdate.getTime(),
          proxy: workingProxy?.name
        }));
        
        console.log(`‚úÖ TLE data updated: ${tleData.length} satellites loaded`);
      } else {
        throw new Error('No valid satellites found in TLE data');
      }
    } catch (error) {
      console.error('TLE update failed:', error);
      updateTLEStatus('error', `‚ùå Update failed: ${error.message}`);
      loadStoredTLEData();
    } finally {
      document.getElementById('updateBtn').disabled = false;
    }
  }

  // Load stored TLE data from localStorage
  function loadStoredTLEData() {
    try {
      const stored = localStorage.getItem('satelliteTLEData');
      if (stored) {
        const parsed = JSON.parse(stored);
        tleData = parsed.data || [];
        lastTLEUpdate = new Date(parsed.timestamp || Date.now());
        
        if (tleData.length > 0) {
          updateTLEStatus('success', `üì± Loaded ${tleData.length} satellites from cache (${parsed.proxy || 'Unknown'})`);
          populateDropdown();
          updateStatusIndicators();
          console.log('Loaded TLE data from localStorage');
          return true;
        }
      }
    } catch (error) {
      console.error('Error loading stored TLE data:', error);
    }
    return false;
  }

  // Populate satellite dropdown
  function populateDropdown() {
    const dropdown = document.getElementById('satDropdown');
    dropdown.innerHTML = '<option value="">-- Select Satellite --</option>';
    
    tleData.forEach((sat, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = `${sat.icon} ${sat.name}`;
      dropdown.appendChild(option);
    });
  }

  // Clear all markers from map
  function clearAllMarkers() {
    markers.forEach((marker) => {
      if (marker && marker.icon) {
        map.removeLayer(marker.icon);
        map.removeLayer(marker.label);
      }
    });
    orbitPaths.forEach(path => map.removeLayer(path));
    markers = [];
    orbitPaths = [];
  }

  // Coordinate validation
  function isValidCoordinate(lat, lng) {
    return !isNaN(lat) && !isNaN(lng) && 
           isFinite(lat) && isFinite(lng) &&
           lat >= -90 && lat <= 90 && 
           lng >= -180 && lng <= 180;
  }

  // Calculate satellite speed
  function calculateSpeed(satrec, time) {
    try {
      const position1 = satellite.propagate(satrec, time);
      const position2 = satellite.propagate(satrec, new Date(time.getTime() + 1000));
      
      if (position1.position && position2.position && 
          position1.position.x && position2.position.x) {
        const dx = position2.position.x - position1.position.x;
        const dy = position2.position.y - position1.position.y;
        const dz = position2.position.z - position1.position.z;
        
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
        return (distance * 3600).toFixed(2); // km/h
      }
    } catch (error) {
      console.error('Speed calculation error:', error);
    }
    return '0';
  }

  // Get orbit points for visualization
  function getOrbitPoints(satrec) {
    const points = [];
    const now = new Date();
    
    try {
      for (let i = 0; i < CONFIG.ORBIT_POINTS; i++) {
        const time = new Date(now.getTime() + i * 60 * 1000);
        const position = satellite.propagate(satrec, time);
        
        if (position.position && !position.error) {
          const geo = satellite.eciToGeodetic(position.position, satellite.gstime(time));
          const lat = satellite.degreesLat(geo.latitude);
          const lon = satellite.degreesLong(geo.longitude);
          
          if (isValidCoordinate(lat, lon)) {
            points.push([lat, lon]);
          }
        }
      }
    } catch (error) {
      console.error('Orbit calculation error:', error);
    }
    
    return points;
  }

  // Check if satellite is currently visible
  function isCurrentlyVisible(satrec) {
    try {
      const now = new Date();
      const position = satellite.propagate(satrec, now);
      
      if (!position.position || position.error) return false;
      
      const lookAngles = calculateLookAngles(
        CONFIG.USER_LOCATION.lat,
        CONFIG.USER_LOCATION.lng,
        CONFIG.USER_LOCATION.elevation,
        position.position
      );
      
      return lookAngles.elevation >= CONFIG.MIN_ELEVATION;
    } catch (error) {
      return false;
    }
  }

  // Update satellite positions
  function updateSatellites() {
    if (tleData.length === 0) return;
    
    const now = new Date();
    let activeCount = 0;
    
    tleData.forEach((sat, i) => {
      try {
        const satrec = satellite.twoline2satrec(sat.tle1, sat.tle2);
        if (!satrec) return;

        const position = satellite.propagate(satrec, now);
        if (!position.position || position.error) return;

        const geo = satellite.eciToGeodetic(position.position, satellite.gstime(now));
        const lat = satellite.degreesLat(geo.latitude);
        const lon = satellite.degreesLong(geo.longitude);

        if (!isValidCoordinate(lat, lon)) return;

        activeCount++;

        if (markers[i]) {
          markers[i].icon.setLatLng([lat, lon]);
          markers[i].label.setLatLng([lat - 1.5, lon]);
          
          if (showOrbits && orbitPaths[i]) {
            const orbitPoints = getOrbitPoints(satrec);
            if (orbitPoints.length > 0) {
              orbitPaths[i].setLatLngs(orbitPoints);
            }
          }
        } else {
          const iconMarker = L.marker([lat, lon], {
            icon: L.divIcon({
              className: 'satellite-icon',
              html: 'üõ∞Ô∏è',
              iconSize: [32, 32],
              iconAnchor: [16, 16]
            })
          });

          const label = L.marker([lat - 1.5, lon], {
            icon: L.divIcon({
              className: 'satellite-label',
              html: sat.icon,
              iconSize: [30, 30],
              iconAnchor: [15, 15]
            }),
            interactive: false
          });

          const orbitPoints = getOrbitPoints(satrec);
          const orbitPath = L.polyline(orbitPoints, {
            color: '#00ffe0',
            weight: 2,
            opacity: 0.6,
            dashArray: '5, 5'
          });

          markers.push({ icon: iconMarker, label: label });
          orbitPaths.push(orbitPath);
        }
        
        if (selectedSatellite === i) {
          updateSatelliteInfo(sat, i);
        }

      } catch (error) {
        console.error(`Update failed for ${sat.name}: ${error.message}`);
      }
    });
    
    document.getElementById('updateStatus').textContent = `Active (${activeCount})`;
  }

  // Update satellite info panel
  function updateSatelliteInfo(sat, index) {
    try {
      const now = new Date();
      const satrec = satellite.twoline2satrec(sat.tle1, sat.tle2);
      
      if (!satrec) {
        document.getElementById('satelliteInfo').innerHTML = 
          '<div style="text-align: center; color: #ff0000;">Error parsing satellite data</div>';
        return;
      }
      
      const position = satellite.propagate(satrec, now);
      if (!position.position || position.error) {
        document.getElementById('satelliteInfo').innerHTML = 
          '<div style="text-align: center; color: #ff0000;">Error calculating position</div>';
        return;
      }
      
      const geo = satellite.eciToGeodetic(position.position, satellite.gstime(now));
      const lat = satellite.degreesLat(geo.latitude);
      const lon = satellite.degreesLong(geo.longitude);
      const alt = geo.height;
      
      if (!isValidCoordinate(lat, lon)) {
        document.getElementById('satelliteInfo').innerHTML = 
          '<div style="text-align: center; color: #ff0000;">Invalid coordinates</div>';
        return;
      }
      
      const speed = calculateSpeed(satrec, now);
      const currentlyVisible = isCurrentlyVisible(satrec);
      const passes = predictNextPass(satrec, CONFIG.PASS_PREDICTION_HOURS);
      
      // Calculate current look angles
      const lookAngles = calculateLookAngles(
        CONFIG.USER_LOCATION.lat,
        CONFIG.USER_LOCATION.lng,
        CONFIG.USER_LOCATION.elevation,
        position.position
      );
      
      const passType = alt > 35000 ? 'Geostationary' : 'Low Earth Orbit';
      
      // Generate pass information HTML
      let passInfoHTML = '';
      if (currentlyVisible) {
        passInfoHTML = `
          <div class="pass-info visible">
            ‚ú® CURRENTLY VISIBLE!
            <br>Elevation: ${lookAngles.elevation.toFixed(1)}¬∞ | Az: ${lookAngles.azimuth.toFixed(0)}¬∞
          </div>
        `;
      } else if (passes.length > 0) {
        const nextPass = passes[0];
        const minutesToPass = Math.round((nextPass.startTime - now) / 1000 / 60);
        const isSoon = minutesToPass < 60;
        
        passInfoHTML = `
          <div class="pass-info ${isSoon ? 'soon' : ''}">
            ${isSoon ? '‚è∞' : 'üìÖ'} Next Pass: ${formatDate(nextPass.startTime)} ${formatTime(nextPass.startTime)}
            <br>Duration: ${Math.round(nextPass.duration)}min | Max El: ${nextPass.maxElevation.toFixed(0)}¬∞
            ${isSoon ? `<br>üöÄ In ${minutesToPass} minutes!` : ''}
          </div>
        `;
      } else {
        passInfoHTML = `
          <div class="pass-info">
            üåå No visible passes in next 24h
          </div>
        `;
      }
      
      const infoPanel = document.getElementById('satelliteInfo');
      infoPanel.innerHTML = `
        <div style="text-align: center; color: #00ffe0; margin-bottom: 15px; font-weight: 700; font-size: 13px;">
          ${sat.icon} ${sat.name}
        </div>
        <div class="info-row">
          <span class="info-label">NORAD ID:</span>
          <span class="info-value">${sat.noradId}</span>
        </div>
        <div class="info-row">
          <span class="info-label">Latitude:</span>
          <span class="info-value">${lat.toFixed(4)}¬∞</span>
        </div>
        <div class="info-row">
          <span class="info-label">Longitude:</span>
          <span class="info-value">${lon.toFixed(4)}¬∞</span>
        </div>
        <div class="info-row">
          <span class="info-label">Altitude:</span>
          <span class="info-value">${alt.toFixed(2)} km</span>
        </div>
        <div class="info-row">
          <span class="info-label">Speed:</span>
          <span class="info-value">${speed} km/h</span>
        </div>
        <div class="info-row">
          <span class="info-label">Orbit Type:</span>
          <span class="info-value">${passType}</span>
        </div>
        <div class="info-row">
          <span class="info-label">Last Update:</span>
          <span class="info-value">${now.toLocaleTimeString()}</span>
        </div>
        ${passInfoHTML}
      `;
    } catch (error) {
      console.error(`Info update failed for ${sat.name}: ${error.message}`);
      document.getElementById('satelliteInfo').innerHTML = 
        '<div style="text-align: center; color: #ff0000;">Update failed</div>';
    }
  }

  // Control functions
  function switchMapType(type) {
    const buttons = document.querySelectorAll('.map-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    
    if (type === 'satellite') {
      map.removeLayer(streetLayer);
      satelliteLayer.addTo(map);
      buttons[0].classList.add('active');
    } else {
      map.removeLayer(satelliteLayer);
      streetLayer.addTo(map);
      buttons[1].classList.add('active');
    }
  }

  function showAllSatellites() {
    selectedSatellite = null;
    document.getElementById('satDropdown').value = '';
    markers.forEach((marker, i) => {
      if (marker && marker.icon) {
        marker.icon.addTo(map);
        marker.label.addTo(map);
        if (showOrbits && orbitPaths[i]) orbitPaths[i].addTo(map);
      }
    });
    // Center map appropriately
    if (hasRealLocation) {
      map.setView([CONFIG.USER_LOCATION.lat, CONFIG.USER_LOCATION.lng], 3);
    } else {
      map.setView([20, 0], 2); // Global view if no location
    }
    document.getElementById('satelliteInfo').innerHTML = 
      `<div style="text-align: center; color: #00ffe0; margin: 20px 0;">Showing ${tleData.length} satellites<br>üìç Tracking passes over ${CONFIG.USER_LOCATION.name || locationStatus}</div>`;
    
    if (isMobile && mobileMenuOpen) {
      toggleMobilePanel();
    }
  }

  function clearAllSatellites() {
    selectedSatellite = null;
    document.getElementById('satDropdown').value = '';
    markers.forEach((marker, i) => {
      if (marker && marker.icon) {
        map.removeLayer(marker.icon);
        map.removeLayer(marker.label);
        if (orbitPaths[i]) map.removeLayer(orbitPaths[i]);
      }
    });
    document.getElementById('satelliteInfo').innerHTML = 
      '<div style="text-align: center; color: #00ffe0; margin: 20px 0;">Select a satellite to view details<br>üìç Location: ' + (CONFIG.USER_LOCATION.name || locationStatus) + '</div>';
    
    if (isMobile && mobileMenuOpen) {
      toggleMobilePanel();
    }
  }

  function toggleOrbits() {
    showOrbits = !showOrbits;
    const button = event.target;
    button.textContent = showOrbits ? 'Hide Orbits' : 'Orbits';
    
    if (selectedSatellite !== null) {
      if (showOrbits && orbitPaths[selectedSatellite]) {
        orbitPaths[selectedSatellite].addTo(map);
      } else if (orbitPaths[selectedSatellite]) {
        map.removeLayer(orbitPaths[selectedSatellite]);
      }
    } else {
      markers.forEach((marker, i) => {
        if (marker && map.hasLayer(marker.icon) && orbitPaths[i]) {
          if (showOrbits) {
            orbitPaths[i].addTo(map);
          } else {
            map.removeLayer(orbitPaths[i]);
          }
        }
      });
    }
  }

  // Setup automatic updates
  function setupAutoUpdates() {
    updateInterval = setInterval(updateSatellites, CONFIG.POSITION_UPDATE_INTERVAL);
    
    if (CONFIG.AUTO_UPDATE_ENABLED) {
      tleUpdateInterval = setInterval(() => {
        console.log('üîÑ Auto-updating TLE data...');
        updateTLEData();
      }, CONFIG.TLE_UPDATE_INTERVAL);
    }
    
    setInterval(updateStatusIndicators, 60000);
  }

  // Initialize application
  async function initialize() {
    console.log('üõ∞Ô∏è Initializing Enhanced Satellite Tracker with Real Location and Pass Predictions...');
    
    initializeMap();
    
    const hasStoredData = loadStoredTLEData();
    
    if (hasStoredData) {
      const dataAge = Date.now() - lastTLEUpdate.getTime();
      if (dataAge > 12 * 60 * 60 * 1000) {
        setTimeout(() => updateTLEData(), 2000);
      }
    } else {
      await updateTLEData();
    }
    
    document.getElementById('satDropdown').addEventListener('change', (e) => {
      const selectedIndex = parseInt(e.target.value);
      selectedSatellite = isNaN(selectedIndex) ? null : selectedIndex;
      
      if (isMobile && mobileMenuOpen) {
        toggleMobilePanel();
      }
      
      markers.forEach((marker, i) => {
        if (isNaN(selectedIndex)) {
          map.removeLayer(marker.icon);
          map.removeLayer(marker.label);
          if (orbitPaths[i]) map.removeLayer(orbitPaths[i]);
        } else if (i === selectedIndex) {
          marker.icon.addTo(map);
          marker.label.addTo(map);
          if (showOrbits && orbitPaths[i]) orbitPaths[i].addTo(map);
          map.setView(marker.icon.getLatLng(), 4);
          updateSatelliteInfo(tleData[i], i);
        } else {
          map.removeLayer(marker.icon);
          map.removeLayer(marker.label);
          if (orbitPaths[i]) map.removeLayer(orbitPaths[i]);
        }
      });
      
      if (isNaN(selectedIndex)) {
        document.getElementById('satelliteInfo').innerHTML = 
          '<div style="text-align: center; color: #00ffe0; margin: 20px 0;">Select a satellite to view details<br>üìç Location: ' + (CONFIG.USER_LOCATION.name || locationStatus) + '</div>';
      }
    });
    
    window.addEventListener('resize', handleResize);
    setupAutoUpdates();
    
    console.log('‚úÖ Enhanced Satellite Tracker Initialized Successfully');
    console.log(`üì° Working Proxy: ${workingProxy?.name || 'None'}`);
    console.log(`üõ∞Ô∏è Satellites Loaded: ${tleData.length}`);
    console.log(`üìç Real Location Tracking: Enabled`);
  }

  window.addEventListener('DOMContentLoaded', initialize);

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      document.getElementById('updateStatus').textContent = 'Paused';
    } else {
      document.getElementById('updateStatus').textContent = 'Active';
    }
  });

  console.log('üöÄ Enhanced Satellite Tracker Script Loaded - Ready for real location tracking and pass predictions!');
</script>


<!-- Custom Cursor Script (before closing </body> tag) -->
<script src="customcursor.js"></script>

</body>
</html>